module Prelude;
open Prelude.internal as internal;

let if c t f = match c with {| true -> t; | false -> f;};

let convert x = int (x) + 10;

let show str = string (10) + str;

let rec fac (n:Nat) : Nat = if (n=0) 1 (n * fac (n-1));

let rec facAcc (n:Nat) acc : Nat = match n with
      {
          | Zero -> acc;
          | Suc m -> facAcc m (n * acc);
      };

let rec fib n = match n with {
  | Zero -> Suc Zero;
  | (Suc Zero)@m -> m;
  | Suc (Suc m)@n1 -> fib m + fib n1;
};

let fac =
    let rec facAcc n acc = match n with
      {
          | Zero -> acc;
          | Suc m -> let acc'=n*acc in facAcc m acc';
      }
    in fun n => facAcc n 0;

let Absurd : Empty -> T = fun zero => match (zero:Empty) with absurd;

let testpair p = 
    let (Tuple fst snd) = p in
    let (Tuple (Tuple x)@a (Tuple y)@z) = snd in
    let tail = (z) ^Stream.tail in
    let r = { (let x = f z in y) with snd = b}
    in Tuple fst snd;